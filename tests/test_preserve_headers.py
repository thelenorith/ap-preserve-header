"""
Generated By: Cursor (Claude Sonnet 4.5)

Unit tests for ap_preserve_header.preserve_headers module.
"""

import os
from pathlib import Path
from unittest.mock import MagicMock, patch

import pytest
from astropy.io import fits

from ap_preserve_header import preserve_headers


class TestExtractKeyValuePairs:
    """Tests for extract_key_value_pairs function."""

    def test_extract_simple_key_value(self):
        """Test extraction of simple key-value pairs."""
        path = Path("/root/KEY_value/file.fits")
        result = preserve_headers.extract_key_value_pairs(path)
        assert "KEY" in result
        assert result["KEY"] == "value"

    def test_extract_multiple_key_values(self):
        """Test extraction of multiple key-value pairs."""
        path = Path("/root/CAMERA_TestCam/OPTIC_C8E/file.fits")
        result = preserve_headers.extract_key_value_pairs(path)
        assert "CAMERA" in result
        assert result["CAMERA"] == "TestCam"
        assert "OPTIC" in result
        assert result["OPTIC"] == "C8E"

    def test_extract_with_hyphen_separator(self):
        """Test extraction with hyphen separator."""
        path = Path("/root/KEY-value/file.fits")
        result = preserve_headers.extract_key_value_pairs(path)
        assert "KEY" in result
        assert result["KEY"] == "value"

    def test_extract_uppercase_keys(self):
        """Test that keys are converted to uppercase."""
        path = Path("/root/camera_TestCam/file.fits")
        result = preserve_headers.extract_key_value_pairs(path)
        assert "CAMERA" in result
        assert result["CAMERA"] == "TestCam"

    def test_extract_ignores_common_directories(self):
        """Test that common directories are ignored."""
        path = Path("/root/./../KEY_value/file.fits")
        result = preserve_headers.extract_key_value_pairs(path)
        assert "KEY" in result
        assert result["KEY"] == "value"

    def test_extract_no_key_value_pairs(self):
        """Test path with no key-value pairs."""
        path = Path("/root/normal/directory/file.fits")
        result = preserve_headers.extract_key_value_pairs(path)
        assert result == {}

    def test_extract_first_path_takes_precedence(self):
        """Test that first path components take precedence (ap-common behavior)."""
        path = Path("/root/KEY_first/KEY_second/file.fits")
        result = preserve_headers.extract_key_value_pairs(path)
        assert (
            result["KEY"] == "first"
        )  # First occurrence takes precedence (ap-common behavior)

    def test_extract_multiple_pairs_in_single_directory(self):
        """Test extraction of multiple key-value pairs in a single directory name."""
        path = Path("/root/DATE_2026-01-20_INSTRUME_ATR585M_OFFSET_150/file.fits")
        result = preserve_headers.extract_key_value_pairs(path)
        assert "DATE" in result
        assert result["DATE"] == "2026-01-20"
        assert "INSTRUME" in result
        assert result["INSTRUME"] == "ATR585M"
        assert "OFFSET" in result
        assert result["OFFSET"] == "150"

    def test_extract_multiple_pairs_with_hyphen_separator(self):
        """Test extraction of multiple key-value pairs with hyphen separators."""
        path = Path("/root/DATE-2026-01-20_INSTRUME-ATR585M/file.fits")
        result = preserve_headers.extract_key_value_pairs(path)
        assert "DATE" in result
        assert result["DATE"] == "2026-01-20"
        assert "INSTRUME" in result
        assert result["INSTRUME"] == "ATR585M"


class TestShouldIncludeHeader:
    """Tests for should_include_header function."""

    def test_include_specific_headers(self):
        """Test including specific headers when list provided."""
        include_list = ["CAMERA", "OPTIC"]
        assert preserve_headers.should_include_header("CAMERA", include_list)
        assert preserve_headers.should_include_header("OPTIC", include_list)
        assert not preserve_headers.should_include_header("OTHER", include_list)

    def test_case_insensitive(self):
        """Test that header matching is case-insensitive."""
        include_list = ["CAMERA", "OPTIC"]
        assert preserve_headers.should_include_header("camera", include_list)
        assert preserve_headers.should_include_header("Camera", include_list)
        assert preserve_headers.should_include_header("OPTIC", include_list)


class TestGetHeaderValue:
    """Tests for get_header_value function."""

    def test_get_from_fits_header(self, sample_fits_file):
        """Test getting value from FITS header."""
        with fits.open(str(sample_fits_file), mode="update") as hdul:
            header = hdul[0].header
            header["TESTKEY"] = "testvalue"
            hdul.flush()

        with fits.open(str(sample_fits_file)) as hdul:
            header = hdul[0].header
            value = preserve_headers.get_header_value(header, "TESTKEY")
            assert value == "testvalue"

    def test_get_from_fits_header_numeric(self, sample_fits_file):
        """Test getting numeric value from FITS header."""
        with fits.open(str(sample_fits_file), mode="update") as hdul:
            header = hdul[0].header
            header["NUMKEY"] = 42
            hdul.flush()

        with fits.open(str(sample_fits_file)) as hdul:
            header = hdul[0].header
            value = preserve_headers.get_header_value(header, "NUMKEY")
            assert value == "42"

    def test_get_missing_key(self, sample_fits_file):
        """Test getting missing key returns None."""
        with fits.open(str(sample_fits_file)) as hdul:
            header = hdul[0].header
            value = preserve_headers.get_header_value(header, "MISSING")
            assert value is None

    def test_get_from_xisf_header(self, sample_xisf_file):
        """Test getting value from XISF header."""
        from xisf import XISF

        # Read the file to get image data and metadata
        image_metadata = {}
        xisf_metadata = {}
        image_data = XISF.read(
            str(sample_xisf_file),
            image_metadata=image_metadata,
            xisf_metadata=xisf_metadata,
        )

        # Add header value to metadata
        if "FITSKeywords" not in image_metadata:
            image_metadata["FITSKeywords"] = {}
        image_metadata["FITSKeywords"]["TESTKEY"] = [
            {"value": "testvalue", "comment": ""}
        ]

        # Write back with updated metadata
        XISF.write(str(sample_xisf_file), image_data, image_metadata=image_metadata)

        # Read using our function
        header_dict = preserve_headers.read_xisf_header(sample_xisf_file)
        value = preserve_headers.get_header_value(header_dict, "TESTKEY")
        assert value == "testvalue"


class TestSetHeaderValue:
    """Tests for set_header_value function."""

    def test_set_in_fits_header(self, sample_fits_file):
        """Test setting value in FITS header."""
        with fits.open(str(sample_fits_file), mode="update") as hdul:
            header = hdul[0].header
            preserve_headers.set_header_value(header, "NEWKEY", "newvalue", "comment")
            hdul.flush()

        with fits.open(str(sample_fits_file)) as hdul:
            header = hdul[0].header
            assert header["NEWKEY"] == "newvalue"

    def test_set_in_xisf_header(self, sample_xisf_file):
        """Test setting value in XISF header."""
        # This test just verifies set_header_value works on a dict
        # The actual XISF file writing is tested in preserve_headers tests
        header_dict = preserve_headers.read_xisf_header(sample_xisf_file)

        preserve_headers.set_header_value(header_dict, "NEWKEY", "newvalue")
        assert header_dict["NEWKEY"] == "newvalue"


class TestPreserveHeaders:
    """Tests for preserve_headers function."""

    def test_preserve_headers_fits_file(self, temp_dir, sample_fits_file):
        """Test preserving headers in FITS file."""
        import shutil

        # Create directory structure with key-value pairs
        test_dir = temp_dir / "CAMERA_TestCam" / "OPTIC_C8E"
        test_dir.mkdir(parents=True)

        # Copy real FITS file to test directory (keeps source immutable)
        fits_path = test_dir / "test.fits"
        shutil.copy2(sample_fits_file, fits_path)

        # Run preserve_headers
        preserve_headers.preserve_headers(
            root_dir=str(temp_dir),
            include_headers=["CAMERA", "OPTIC"],
            dryrun=False,
            quiet=True,
        )

        # Verify headers were added
        with fits.open(str(fits_path)) as hdul:
            header = hdul[0].header
            assert "CAMERA" in header
            assert header["CAMERA"] == "TestCam"
            assert "OPTIC" in header
            assert header["OPTIC"] == "C8E"

    def test_preserve_headers_skips_existing_values(self, temp_dir, sample_fits_file):
        """Test that existing header values are not overwritten if they match."""
        import shutil

        # Create directory structure
        test_dir = temp_dir / "CAMERA_TestCam"
        test_dir.mkdir(parents=True)

        # Copy real FITS file and set existing header value
        fits_path = test_dir / "test.fits"
        shutil.copy2(sample_fits_file, fits_path)
        with fits.open(str(fits_path), mode="update") as hdul:
            hdul[0].header["CAMERA"] = "TestCam"
            hdul.flush()

        # Run preserve_headers
        preserve_headers.preserve_headers(
            root_dir=str(temp_dir),
            include_headers=["CAMERA", "OPTIC"],
            dryrun=False,
            quiet=True,
        )

        # Verify header still has the same value
        with fits.open(str(fits_path)) as hdul:
            header = hdul[0].header
            assert header["CAMERA"] == "TestCam"

    def test_preserve_headers_updates_different_values(
        self, temp_dir, sample_fits_file
    ):
        """Test that header values are updated if they differ from path."""
        import shutil

        # Create directory structure
        test_dir = temp_dir / "CAMERA_NewCam"
        test_dir.mkdir(parents=True)

        # Copy real FITS file and set different header value
        fits_path = test_dir / "test.fits"
        shutil.copy2(sample_fits_file, fits_path)
        with fits.open(str(fits_path), mode="update") as hdul:
            hdul[0].header["CAMERA"] = "OldCam"
            hdul.flush()

        # Run preserve_headers
        preserve_headers.preserve_headers(
            root_dir=str(temp_dir),
            include_headers=["CAMERA", "OPTIC"],
            dryrun=False,
            quiet=True,
        )

        # Verify header was updated
        with fits.open(str(fits_path)) as hdul:
            header = hdul[0].header
            assert header["CAMERA"] == "NewCam"

    def test_preserve_headers_dryrun(self, temp_dir, sample_fits_file):
        """Test preserve_headers with dryrun flag."""
        import shutil

        # Create directory structure
        test_dir = temp_dir / "CAMERA_TestCam"
        test_dir.mkdir(parents=True)

        # Copy real FITS file to test directory (keeps source immutable)
        fits_path = test_dir / "test.fits"
        shutil.copy2(sample_fits_file, fits_path)

        # Run preserve_headers with dryrun
        preserve_headers.preserve_headers(
            root_dir=str(temp_dir), include_headers=["CAMERA"], dryrun=True, quiet=True
        )

        # Verify headers were NOT added (dryrun)
        with fits.open(str(fits_path)) as hdul:
            header = hdul[0].header
            assert "CAMERA" not in header

    def test_preserve_headers_with_preserve_list(self, temp_dir, sample_fits_file):
        """Test preserve_headers with specific preserve list."""
        import shutil

        # Create directory structure
        test_dir = temp_dir / "CAMERA_TestCam" / "OPTIC_C8E" / "OTHER_OtherValue"
        test_dir.mkdir(parents=True)

        # Copy real FITS file to test directory (keeps source immutable)
        fits_path = test_dir / "test.fits"
        shutil.copy2(sample_fits_file, fits_path)

        # Run preserve_headers with include list
        preserve_headers.preserve_headers(
            root_dir=str(temp_dir),
            include_headers=["CAMERA"],
            dryrun=False,
            quiet=True,
        )

        # Verify only CAMERA was added, not OPTIC or OTHER
        with fits.open(str(fits_path)) as hdul:
            header = hdul[0].header
            assert "CAMERA" in header
            assert header["CAMERA"] == "TestCam"
            assert "OPTIC" not in header
            assert "OTHER" not in header

    def test_preserve_headers_xisf_file(self, temp_dir, sample_xisf_file):
        """Test preserving headers in XISF file."""
        from xisf import XISF
        import shutil

        # Create directory structure
        test_dir = temp_dir / "CAMERA_TestCam"
        test_dir.mkdir(parents=True)

        # Copy real XISF file to test directory (keeps source immutable)
        xisf_path = test_dir / "test.xisf"
        shutil.copy2(sample_xisf_file, xisf_path)

        # Run preserve_headers
        preserve_headers.preserve_headers(
            root_dir=str(temp_dir), include_headers=["CAMERA"], dryrun=False, quiet=True
        )

        # Verify headers were added by reading metadata
        image_metadata = {}
        XISF.read(str(xisf_path), image_metadata=image_metadata)
        assert "FITSKeywords" in image_metadata
        assert "CAMERA" in image_metadata["FITSKeywords"]
        # FITSKeywords values are lists of dicts with 'value' and 'comment'
        camera_value = image_metadata["FITSKeywords"]["CAMERA"][0]["value"]
        assert camera_value == "TestCam"

    def test_preserve_headers_invalid_directory(self):
        """Test preserve_headers with invalid directory."""
        with pytest.raises(ValueError, match="does not exist"):
            preserve_headers.preserve_headers(
                root_dir="/nonexistent/path", include_headers=["CAMERA"], quiet=True
            )

    def test_preserve_headers_not_directory(self, temp_dir):
        """Test preserve_headers with file instead of directory."""
        file_path = temp_dir / "notadir.txt"
        file_path.write_text("test")

        with pytest.raises(ValueError, match="not a directory"):
            preserve_headers.preserve_headers(
                root_dir=str(file_path), include_headers=["CAMERA"], quiet=True
            )


class TestMain:
    """Tests for main function."""

    @patch("ap_preserve_header.preserve_headers.preserve_headers")
    def test_main_calls_preserve_headers(self, mock_preserve):
        """Test that main function calls preserve_headers with correct arguments."""
        with patch("sys.argv", ["preserve_headers.py", "/root", "--include", "CAMERA"]):
            preserve_headers.main()

        mock_preserve.assert_called_once_with(
            root_dir="/root",
            include_headers=["CAMERA"],
            dryrun=False,
            quiet=False,
        )

    @patch("ap_preserve_header.preserve_headers.preserve_headers")
    def test_main_with_debug_flag(self, mock_preserve):
        """Test main with --debug flag."""
        with patch(
            "sys.argv",
            ["preserve_headers.py", "/root", "--include", "CAMERA", "--debug"],
        ):
            preserve_headers.main()

        mock_preserve.assert_called_once_with(
            root_dir="/root",
            include_headers=["CAMERA"],
            dryrun=False,
            quiet=False,
        )

    @patch("ap_preserve_header.preserve_headers.preserve_headers")
    def test_main_with_dryrun_flag(self, mock_preserve):
        """Test main with --dryrun flag."""
        with patch(
            "sys.argv",
            ["preserve_headers.py", "/root", "--include", "CAMERA", "--dryrun"],
        ):
            preserve_headers.main()

        mock_preserve.assert_called_once_with(
            root_dir="/root",
            include_headers=["CAMERA"],
            dryrun=True,
            quiet=False,
        )

    @patch("ap_preserve_header.preserve_headers.preserve_headers")
    def test_main_with_include_list(self, mock_preserve):
        """Test main with --include flag."""
        with patch(
            "sys.argv",
            ["preserve_headers.py", "/root", "--include", "CAMERA", "OPTIC"],
        ):
            preserve_headers.main()

        mock_preserve.assert_called_once_with(
            root_dir="/root",
            include_headers=["CAMERA", "OPTIC"],
            dryrun=False,
            quiet=False,
        )

    @patch("ap_preserve_header.preserve_headers.preserve_headers")
    def test_main_with_all_flags(self, mock_preserve):
        """Test main with all flags."""
        with patch(
            "sys.argv",
            [
                "preserve_headers.py",
                "/root",
                "--include",
                "CAMERA",
                "--debug",
                "--dryrun",
            ],
        ):
            preserve_headers.main()

        mock_preserve.assert_called_once_with(
            root_dir="/root",
            include_headers=["CAMERA"],
            dryrun=True,
            quiet=False,
        )

    @patch("ap_preserve_header.preserve_headers.preserve_headers")
    @patch("ap_preserve_header.preserve_headers.setup_logging")
    def test_main_with_quiet_flag(self, mock_setup_logging, mock_preserve):
        """Test main with --quiet flag."""
        import logging

        mock_logger = MagicMock()
        with (
            patch(
                "sys.argv",
                ["preserve_headers.py", "/root", "--include", "CAMERA", "--quiet"],
            ),
            patch("logging.getLogger", return_value=mock_logger),
        ):
            preserve_headers.main()

        mock_preserve.assert_called_once_with(
            root_dir="/root",
            include_headers=["CAMERA"],
            dryrun=False,
            quiet=True,
        )
        mock_setup_logging.assert_called_once_with(
            name="ap_preserve_header.preserve_headers", debug=False, quiet=True
        )

    @patch("ap_preserve_header.preserve_headers.preserve_headers")
    @patch("ap_preserve_header.preserve_headers.setup_logging")
    def test_main_with_quiet_short_flag(self, mock_setup_logging, mock_preserve):
        """Test main with -q short flag."""
        import logging

        mock_logger = MagicMock()
        with (
            patch(
                "sys.argv",
                ["preserve_headers.py", "/root", "--include", "CAMERA", "-q"],
            ),
            patch("logging.getLogger", return_value=mock_logger),
        ):
            preserve_headers.main()

        mock_preserve.assert_called_once_with(
            root_dir="/root",
            include_headers=["CAMERA"],
            dryrun=False,
            quiet=True,
        )
        mock_setup_logging.assert_called_once_with(
            name="ap_preserve_header.preserve_headers", debug=False, quiet=True
        )

    @patch("ap_preserve_header.preserve_headers.preserve_headers")
    @patch("ap_preserve_header.preserve_headers.setup_logging")
    def test_main_quiet_takes_precedence_over_debug(
        self, mock_setup_logging, mock_preserve
    ):
        """Test that --quiet takes precedence over --debug."""
        import logging

        mock_logger = MagicMock()
        with (
            patch(
                "sys.argv",
                [
                    "preserve_headers.py",
                    "/root",
                    "--include",
                    "CAMERA",
                    "--debug",
                    "--quiet",
                ],
            ),
            patch("logging.getLogger", return_value=mock_logger),
        ):
            preserve_headers.main()

        mock_preserve.assert_called_once_with(
            root_dir="/root",
            include_headers=["CAMERA"],
            dryrun=False,
            quiet=True,
        )
        # --debug takes precedence over --quiet in the new implementation
        # Both flags are passed to setup_logging, which will use DEBUG level
        mock_setup_logging.assert_called_once_with(
            name="ap_preserve_header.preserve_headers", debug=True, quiet=True
        )
